По результатам работы был разработан модуль LogProcessor. Данный модуль предоставляет аннотацию \@LogCall, применяемую к методам веб-контроллеров в рамках экосистемы spring boot. К аннотированным эндпоинтам примешивается функционал, логгирующий детали http запроса и его обработки. 

Для логгирования используется встроенная абстракция над логгерами SLF4J, что позволяет конечному разработчику применять необходимую ему технологию логгирования.

Конфигурация модуля производится через application.properties, что предоставляет единый интерфейс конфигурации приложения.

Замечание: В примерах application.properties используются значения, установленные по умолчанию

Лог состоит из 3 частей: Signature, Arguments, Response. Рассмотрим каждый из них.

Signature - часть, рассматривающая следующие детали запроса: метод, url, статус и время обработки. Это максимальная функциональность части, но модуль предоставляет способ исключить из лога ту или иную информацию.

Синтаксис в application.properties:
Добавление обработки синтаксиса:
```application.properties
http.logging.signature.enableSignatureLogging=true
```

Формат лога можно настраивать с помощью следующего свойства:
```application.properties
http.logging.signature.format = %method %url %status %duration
```
четыре ключевые слова в строке заменяются значениям, захваченными логгирующей подсистемой. Пользователь может определить формат альтернативным образом, к примеру:
```application.properties
http.logging.signature.format = METHOD=[%method] STATUS=[%status] DURATION=[%duration] 
```

Arguments - часть, рассматривающая аргументы(свойства) запроса. Часть предоставляет способ маскирования чувствительных данных, как и способ задания ключей, которые должны быть замаскированы в логе.

Синтаксис в application.properties
```application.properties
http.logging.arguments.enableArgumentLogging = true
```

Для указания маскируемых параметров используется следующее свойство
```application.properties
http.logging.arguments.secured keys =
```
После знака равенства можно указать через запятую список наименований аргументов, чьи значения будут заменены на \*\*\*\*\*

Response - часть, рассматривающая значение responseBody, которое возвращается эндпоинтом. Конфигурационный файл позволяет задать список URI, при обращении к которым в лог не будет записано значений response.

Синтаксис в application.properties

Подключение или отключение лога ответов приложения:
```
http.logging.response.enableResponseLogging=true
```

Добавление URI ответы на которые будут проигнорированы осуществляется через следующую команду:
```
http.logging.response.ignoreResponseFor=
```
Через запятую можно указать URI

Также модуль предоставляет свойство URIProperties, которое позволяет задать список URI, которые в принципе не будут логгироваться. 

Включение фильтрации осуществляется с помощью свойства:

```
http.logging.uriProperties.enableURIFiltering=true
```

Список игнорируемых URI можно задать через:
```
http.logging.ignoredURI=
```
через запятую можно указать список игнорируемых URI.

---
### Реализация
В основе обработки логов стоит паттерн chain of responsibility. 
Абстрактный класс LogProcessor применяет абстрактную функцию к data классу LogContext, модифицируя значение log через addLog на основе свойств LogContext, после чего передает управление следующему процессору, если такой указан в объекте.

Цепь всегда начинается с EmptyLogProcessor, который не делает с логом ничего. После выполнения всех процессоров, результрующая строка логгируется с использованием абстракции slf4j.

Цепь собирается в конфигурационном объекте RequestLogConfiguration при старте приложения на основе свойств LogConfigurationProperties. В зависимости от значений последнего, в цепь добавляются те или иные процессоры, параметризованные в соответствии со значениями из application.properties.

### Возможности развития проекта

Проект предоставляет далеко не все опции конфигурирования, которые позволяет реализовать примененный паттерн. В качестве примеров можно добавить в каждый из используемых процессоров список игнорируемых URI, как это сделано в ResponseLogProcessor, применить ко всем процессорам механики форматирования, как выполнено в SignatureProcessor.

### Не решенные задачи

На текущем этапе и с текущими ограничениями по времени для меня осталось неизвестным, как реализовать следующие идеи:
- Добавление пользовательских процессоров.
	- Цепь конструируется статически только с уже определенными в проекте процессорами. Как отойти от явного указания всех процессоров в алгоритме построения осталось для меня не решенной задачей. Было бы здорово реализовать добавление класса пользовательского процессора на основе аннотации.
- Логгирование деталей HTTP ответа кроме тела ответа
	- В текущей реализации логгер работает только с методами контроллера, помеченными как @RequestBody, которые возвращают строку. Получение из контекста приложения значения HttpResponse черевато, ведь прочитать его значение можно лишь единожды.
- Тестирование приложения
	- При текущей реализации я не придумал, как реализовать Unit-тестирование, ведь LogContext включает в себя объекты HttpServletRequest, получаемый из контекста приложения в runtime. Тем не менее, в случае решения данной проблемы, можно было бы независимо протестировать результат сборки цепи процессоров, ведь ее конструкция опирается на класс LogConfigurationProperties, который можно с помощью mock'ирования модифицировать, чтобы применять разные свойства. Тестирование на текущем этапе проводилось вручную на основе второстепенного проекта с базовыми контроллерами UserController и OrderController, являвшееся развитием проекта с домашнего задания 1.
